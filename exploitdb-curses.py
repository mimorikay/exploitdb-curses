import curses
import requests
import sqlite3
import os
import webbrowser
import time
from datetime import datetime, timedelta
import threading

BASE_URL = "https://www.exploit-db.com/search"
DB_NAME = "exploit_database.db"
HEADERS = {
    "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36",
    "X-Requested-With": "XMLHttpRequest",
}

def create_database():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS exploits
                 (id INTEGER PRIMARY KEY, description TEXT, type_id TEXT,
                  platform_id TEXT, date_published TEXT, verified INTEGER,
                  port TEXT, author TEXT, url TEXT)''')
    c.execute('''CREATE TABLE IF NOT EXISTS bookmarks
                 (id INTEGER PRIMARY KEY, exploit_id INTEGER,
                  FOREIGN KEY(exploit_id) REFERENCES exploits(id))''')
    c.execute('''CREATE TABLE IF NOT EXISTS preferences
                 (id INTEGER PRIMARY KEY, color_scheme TEXT)''')
    conn.commit()
    conn.close()

def fetch_and_store_exploits(start_index=0, results_per_page=100, last_date=None):
    params = {
        "q": "",  # Empty query to get all exploits
        "start": start_index,
        "length": results_per_page,
    }

    if last_date:
        params["after"] = last_date

    try:
        response = requests.get(BASE_URL, params=params, headers=HEADERS)
        response.raise_for_status()
        data = response.json()
        exploits = data.get('data', [])
        total_count = data.get('recordsTotal', 0)

        if not exploits:
            return 0, total_count

        conn = sqlite3.connect(DB_NAME)
        c = conn.cursor()

        for exploit in exploits:
            c.execute('''INSERT OR REPLACE INTO exploits
                         (id, description, type_id, platform_id, date_published,
                          verified, port, author, url)
                         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)''',
                      (int(exploit['id']), exploit['description'][1], exploit['type_id'],
                       exploit['platform_id'], exploit['date_published'],
                       exploit['verified'], exploit['port'], exploit['author']['name'],
                       f"https://www.exploit-db.com/exploits/{exploit['id']}"))
        conn.commit()
        conn.close()
        return len(exploits), total_count

    except Exception as e:
        print(f"Error fetching exploits: {e}")
        return 0, 0

def fetch_all_exploits(progress_callback=None):
    total_fetched = 0
    start_index = 0
    total_count = 0

    while True:
        fetched, total_count = fetch_and_store_exploits(start_index=start_index)
        if fetched == 0:
            break
        total_fetched += fetched
        start_index += fetched
        if progress_callback:
            progress_callback(total_fetched, total_count)

    return total_fetched

def fetch_new_exploits():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute("SELECT MAX(date_published) FROM exploits")
    last_date = c.fetchone()[0]
    conn.close()

    if last_date:
        total_fetched, _ = fetch_and_store_exploits(start_index=0, last_date=last_date)
    else:
        total_fetched = fetch_all_exploits()

    return total_fetched

def get_exploits_from_db(offset=0, limit=20, search_term=None, sort_by="id", sort_order="DESC", platform=None, verified=None, date_range=None):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    query = '''SELECT id, description, platform_id, verified, date_published FROM exploits'''
    conditions = []
    params = []

    if search_term:
        conditions.append("description LIKE ?")
        params.append(f'%{search_term}%')

    if platform:
        conditions.append("platform_id = ?")
        params.append(platform)

    if verified is not None:
        conditions.append("verified = ?")
        params.append(int(verified))

    if date_range:
        start_date, end_date = date_range
        conditions.append("date_published BETWEEN ? AND ?")
        params.extend([start_date, end_date])

    if conditions:
        query += " WHERE " + " AND ".join(conditions)

    query += f" ORDER BY {sort_by} {sort_order} LIMIT ? OFFSET ?"
    params.extend([limit, offset])

    c.execute(query, params)
    exploits = c.fetchall()
    conn.close()
    return exploits

def get_exploit_details(exploit_id):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('SELECT * FROM exploits WHERE id = ?', (exploit_id,))
    exploit = c.fetchone()
    conn.close()
    return exploit

def add_bookmark(exploit_id):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('INSERT OR IGNORE INTO bookmarks (exploit_id) VALUES (?)', (exploit_id,))
    conn.commit()
    conn.close()

def remove_bookmark(exploit_id):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('DELETE FROM bookmarks WHERE exploit_id = ?', (exploit_id,))
    conn.commit()
    conn.close()

def get_bookmarks():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''SELECT e.id, e.description, e.platform_id, e.verified, e.date_published
                 FROM exploits e
                 JOIN bookmarks b ON e.id = b.exploit_id
                 ORDER BY e.id DESC''')
    bookmarks = c.fetchall()
    conn.close()
    return bookmarks

def save_color_scheme(color_scheme):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('INSERT OR REPLACE INTO preferences (id, color_scheme) VALUES (1, ?)', (color_scheme,))
    conn.commit()
    conn.close()

def load_color_scheme():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('SELECT color_scheme FROM preferences WHERE id = 1')
    result = c.fetchone()
    conn.close()
    return result[0] if result else 'default'

class ExploitApplication:
    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.exploits = []
        self.current_index = 0
        self.offset = 0
        self.search_mode = False
        self.search_string = ""
        self.sort_by = "id"
        self.sort_order = "DESC"
        self.platform_filter = None
        self.verified_filter = None
        self.date_range_filter = None
        self.view_mode = "main"  # Can be "main", "bookmarks", or "help"
        self.color_scheme = load_color_scheme()
        self.setup_colors()
        self.initialize_application()
        self.last_update_check = datetime.now()
        self.new_exploits_count = 0
        threading.Thread(target=self.background_update_check, daemon=True).start()

    def setup_colors(self):
        curses.start_color()
        if self.color_scheme == 'dark':
            curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)
            curses.init_pair(2, curses.COLOR_RED, curses.COLOR_BLACK)
            curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)
            curses.init_pair(4, curses.COLOR_BLUE, curses.COLOR_BLACK)
        elif self.color_scheme == 'light':
            curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_WHITE)
            curses.init_pair(2, curses.COLOR_RED, curses.COLOR_WHITE)
            curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_WHITE)
            curses.init_pair(4, curses.COLOR_BLUE, curses.COLOR_WHITE)
        else:  # default
            curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)
            curses.init_pair(2, curses.COLOR_RED, curses.COLOR_BLACK)
            curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)
            curses.init_pair(4, curses.COLOR_BLUE, curses.COLOR_BLACK)

    def initialize_application(self):
        self.stdscr.clear()
        self.stdscr.addstr(0, 0, "Initializing exploitdb_curses...")
        self.stdscr.refresh()
        self.stdscr.addstr(2, 0, "Checking database...")
        self.stdscr.refresh()
        self.check_and_load_initial_data()
        self.stdscr.addstr(4, 0, "Loading exploits...")
        self.stdscr.refresh()
        self.fetch_exploits()
        self.stdscr.addstr(6, 0, "Initialization complete. Press any key to continue.")
        self.stdscr.refresh()
        self.stdscr.getch()

    def check_and_load_initial_data(self):
        conn = sqlite3.connect(DB_NAME)
        c = conn.cursor()
        c.execute("SELECT COUNT(*) FROM exploits")
        count = c.fetchone()[0]
        conn.close()

        if count == 0:
            self.stdscr.addstr(3, 0, "No exploits found in the database. Fetching initial data...")
            self.stdscr.refresh()
            fetch_all_exploits(self.update_progress)
            self.stdscr.addstr(3, 0, "Initial data fetch complete. ")
            self.stdscr.refresh()
        else:
            self.stdscr.addstr(3, 0, f"Found {count} exploits in the database.")
            self.stdscr.refresh()

    def update_progress(self, current, total):
        bar_length = 50
        filled_length = int(bar_length * current // total)
        bar = '#' * filled_length + '-' * (bar_length - filled_length)
        percent = round(100 * current / total, 1)
        self.stdscr.addstr(4, 0, f"\rProgress: [{bar}] {percent}% ({current}/{total})")
        self.stdscr.refresh()

    def fetch_exploits(self):
        height, _ = self.stdscr.getmaxyx()
        limit = height - 3  # Adjust limit based on terminal height
        if self.view_mode == "bookmarks":
            self.exploits = get_bookmarks()
        else:
            self.exploits = get_exploits_from_db(
                self.offset, limit, self.search_string, self.sort_by, self.sort_order,
                self.platform_filter, self.verified_filter, self.date_range_filter
            )

    def display(self):
        self.stdscr.clear()
        height, width = self.stdscr.getmaxyx()

        if self.view_mode == "help":
            self.display_help()
        else:
            for i, exploit in enumerate(self.exploits):
                if i >= height - 3:
                    break

                if i == self.current_index:
                    self.stdscr.attron(curses.color_pair(4) | curses.A_REVERSE)
                else:
                    self.stdscr.attron(curses.color_pair(4))

                verified_status = "✓" if exploit[3] == 1 else "✗"
                verified_color = curses.color_pair(1) if exploit[3] == 1 else curses.color_pair(2)

                self.stdscr.addstr(i, 0, f"{exploit[0]}: ")
                self.stdscr.addstr(f"[{exploit[2]}] ", curses.color_pair(3))
                self.stdscr.addstr(verified_status, verified_color)
                self.stdscr.addstr(f" {exploit[1][:width-15]}")

                if i == self.current_index:
                    self.stdscr.attroff(curses.color_pair(4) | curses.A_REVERSE)
                else:
                    self.stdscr.attroff(curses.color_pair(4))

            # Display page information
            total_exploits = len(self.exploits)
            current_page = (self.offset // (height - 3)) + 1
            total_pages = (total_exploits + height - 4) // (height - 3)
            page_info = f"Page {current_page}/{total_pages}"
            self.stdscr.addstr(height-2, width-len(page_info)-1, page_info)

        self.stdscr.attron(curses.color_pair(3))
        if self.search_mode:
            self.stdscr.addstr(height-1, 0, f"Search: {self.search_string}")
        else:
            status_line = "Press '/' to search, 'u' to update, 'h' for help, 'q' to quit"
            if self.new_exploits_count > 0:
                status_line = f"{self.new_exploits_count} new exploits available! " + status_line
            self.stdscr.addstr(height-1, 0, status_line[:width-1])
        self.stdscr.attroff(curses.color_pair(3))

        self.stdscr.refresh()

    def display_help(self):
        help_text = [
            "Keyboard Shortcuts:",
            "j/↓: Move down",
            "k/↑: Move up",
            "n: Next page",
            "p: Previous page",
            "g: Go to first exploit",
            "G: Go to last exploit",
            "/: Search mode",
            "s: Sort options",
            "f: Filter options",
            "b: Toggle bookmarks view",
            "u: Check for updates",
            "c: Change color scheme",
            "Enter: Show exploit details",
            "q: Quit application",
            "h: Show/hide this help screen"
        ]

        for i, line in enumerate(help_text):
            self.stdscr.addstr(i, 0, line)

    def handle_input(self):
        key = self.stdscr.getch()

        if self.search_mode:
            if key == 27:  # ESC key
                self.search_mode = False
                self.search_string = ""
            elif key == 10:  # Enter key
                self.search_mode = False
                self.search_exploits()
            elif key == curses.KEY_BACKSPACE or key == 127:
                self.search_string = self.search_string[:-1]
            else:
                self.search_string += chr(key)
        else:
            if key == ord('q'):
                return False
            elif key == ord('/'):
                self.search_mode = True
            elif key == ord('u'):
                self.check_for_updates()
            elif key == ord('j') or key == curses.KEY_DOWN:
                self.current_index = min(self.current_index + 1, len(self.exploits) - 1)
                if self.current_index == len(self.exploits) - 1:
                    self.offset += len(self.exploits)
                    self.fetch_exploits()
            elif key == ord('k') or key == curses.KEY_UP:
                self.current_index = max(self.current_index - 1, 0)
                if self.current_index == 0 and self.offset > 0:
                    self.offset -= len(self.exploits)
                    self.fetch_exploits()
            elif key == ord('n'):
                self.next_page()
            elif key == ord('p'):
                self.previous_page()
            elif key == ord('G'):
                self.current_index = len(self.exploits) - 1
            elif key == ord('g'):
                self.current_index = 0
                self.offset = 0
                self.fetch_exploits()
            elif key == 10:  # Enter key
                self.show_exploit_details()
            elif key == ord('s'):
                self.show_sort_options()
            elif key == ord('f'):
                self.show_filter_options()
            elif key == ord('b'):
                self.toggle_bookmarks_view()
            elif key == ord('c'):
                self.change_color_scheme()
            elif key == ord('h'):
                self.toggle_help_screen()

        return True

    def search_exploits(self):
        self.offset = 0
        self.current_index = 0
        self.fetch_exploits()

    def check_for_updates(self):
        height, width = self.stdscr.getmaxyx()
        self.stdscr.addstr(height-1, 0, "Checking for updates...")
        self.stdscr.refresh()
        new_exploits = fetch_new_exploits()
        self.stdscr.addstr(height-1, 0, f"Found {new_exploits} new exploits. Press any key to continue.")
        self.stdscr.refresh()
        self.stdscr.getch()
        self.fetch_exploits()

    def next_page(self):
        self.offset += len(self.exploits)
        self.current_index = 0
        self.fetch_exploits()

    def previous_page(self):
        if self.offset > 0:
            self.offset = max(0, self.offset - len(self.exploits))
            self.current_index = 0
            self.fetch_exploits()

    def show_exploit_details(self):
        exploit_id = self.exploits[self.current_index][0]
        exploit = get_exploit_details(exploit_id)

        if exploit is None or len(exploit) < 9:
            self.stdscr.addstr(0, 0, "Error: Exploit details not found or incomplete.")
            self.stdscr.refresh()
            self.stdscr.getch()
            return

        details_win = curses.newpad(100, 100)
        details_win.box()
        details_win.addstr(1, 2, f"ID: {exploit[0]}")
        details_win.addstr(2, 2, f"Description: {exploit[1]}")
        details_win.addstr(3, 2, f"Type: {exploit[2]}")
        details_win.addstr(4, 2, f"Platform: {exploit[3]}")
        details_win.addstr(5, 2, f"Published Date: {exploit[4]}")
        details_win.addstr(6, 2, f"Verified: {'Yes' if exploit[5] == 1 else 'No'}")
        details_win.addstr(7, 2, f"Port: {exploit[6]}")
        details_win.addstr(8, 2, f"Author: {exploit[7]}")
        details_win.addstr(9, 2, f"URL: {exploit[8]}")
        details_win.addstr(11, 2, "Press 'o' to open URL in browser, 'b' to bookmark/unbookmark, 'q' to close")

        height, width = self.stdscr.getmaxyx()
        pad_pos = 0

        while True:
            details_win.refresh(pad_pos, 0, 5, 10, height-3, width-10)
            key = details_win.getch()
            if key == ord('q'):
                break
            elif key == ord('o'):
                webbrowser.open(exploit[8])
                details_win.addstr(13, 2, "URL opened in default browser")
            elif key == ord('b'):
                self.toggle_bookmark(exploit_id)
                details_win.addstr(13, 2, "Bookmark toggled")
            elif key == curses.KEY_DOWN and pad_pos < 100 - (height - 8):
                pad_pos += 1
            elif key == curses.KEY_UP and pad_pos > 0:
                pad_pos -= 1

        del details_win

    def show_sort_options(self):
        options = ["ID", "Date", "Platform", "Verification Status"]
        selected = 0

        sort_win = curses.newwin(10, 30, 5, 10)
        sort_win.box()
        sort_win.addstr(1, 2, "Sort by:")

        while True:
            for i, option in enumerate(options):
                if i == selected:
                    sort_win.attron(curses.A_REVERSE)
                sort_win.addstr(i+2, 2, option)
                if i == selected:
                    sort_win.attroff(curses.A_REVERSE)

            sort_win.refresh()
            key = sort_win.getch()

            if key == curses.KEY_UP:
                selected = (selected - 1) % len(options)
            elif key == curses.KEY_DOWN:
                selected = (selected + 1) % len(options)
            elif key == 10:  # Enter key
                if selected == 0:
                    self.sort_by = "id"
                elif selected == 1:
                    self.sort_by = "date_published"
                elif selected == 2:
                    self.sort_by = "platform_id"
                elif selected == 3:
                    self.sort_by = "verified"
                self.sort_order = "DESC" if self.sort_order == "ASC" else "ASC"
                break
            elif key == 27:  # ESC key
                break

        del sort_win
        self.fetch_exploits()

    def show_filter_options(self):
        options = ["Platform", "Verification Status", "Date Range", "Clear Filters"]
        selected = 0

        filter_win = curses.newwin(10, 30, 5, 10)
        filter_win.box()
        filter_win.addstr(1, 2, "Filter by:")

        while True:
            for i, option in enumerate(options):
                if i == selected:
                    filter_win.attron(curses.A_REVERSE)
                filter_win.addstr(i+2, 2, option)
                if i == selected:
                    filter_win.attroff(curses.A_REVERSE)

            filter_win.refresh()
            key = filter_win.getch()

            if key == curses.KEY_UP:
                selected = (selected - 1) % len(options)
            elif key == curses.KEY_DOWN:
                selected = (selected + 1) % len(options)
            elif key == 10:  # Enter key
                if selected == 0:
                    self.set_platform_filter()
                elif selected == 1:
                    self.set_verified_filter()
                elif selected == 2:
                    self.set_date_range_filter()
                elif selected == 3:
                    self.clear_filters()
                break
            elif key == 27:  # ESC key
                break

        del filter_win
        self.fetch_exploits()

    def set_platform_filter(self):
        self.stdscr.addstr(0, 0, "Enter platform (e.g., windows, linux): ")
        curses.echo()
        self.platform_filter = self.stdscr.getstr().decode().strip()
        curses.noecho()

    def set_verified_filter(self):
        self.verified_filter = not self.verified_filter

    def set_date_range_filter(self):
        self.stdscr.addstr(0, 0, "Enter start date (YYYY-MM-DD): ")
        curses.echo()
        start_date = self.stdscr.getstr().decode().strip()
        self.stdscr.addstr(1, 0, "Enter end date (YYYY-MM-DD): ")
        end_date = self.stdscr.getstr().decode().strip()
        curses.noecho()
        self.date_range_filter = (start_date, end_date)

    def clear_filters(self):
        self.platform_filter = None
        self.verified_filter = None
        self.date_range_filter = None

    def toggle_bookmarks_view(self):
        if self.view_mode == "bookmarks":
            self.view_mode = "main"
        else:
            self.view_mode = "bookmarks"
        self.offset = 0
        self.current_index = 0
        self.fetch_exploits()

    def toggle_bookmark(self, exploit_id):
        if self.is_bookmarked(exploit_id):
            remove_bookmark(exploit_id)
        else:
            add_bookmark(exploit_id)

    def is_bookmarked(self, exploit_id):
        conn = sqlite3.connect(DB_NAME)
        c = conn.cursor()
        c.execute('SELECT 1 FROM bookmarks WHERE exploit_id = ?', (exploit_id,))
        result = c.fetchone() is not None
        conn.close()
        return result

    def change_color_scheme(self):
        options = ["Default", "Dark", "Light"]
        selected = options.index(self.color_scheme.capitalize())

        color_win = curses.newwin(10, 30, 5, 10)
        color_win.box()
        color_win.addstr(1, 2, "Select color scheme:")

        while True:
            for i, option in enumerate(options):
                if i == selected:
                    color_win.attron(curses.A_REVERSE)
                color_win.addstr(i+2, 2, option)
                if i == selected:
                    color_win.attroff(curses.A_REVERSE)

            color_win.refresh()
            key = color_win.getch()

            if key == curses.KEY_UP:
                selected = (selected - 1) % len(options)
            elif key == curses.KEY_DOWN:
                selected = (selected + 1) % len(options)
            elif key == 10:  # Enter key
                self.color_scheme = options[selected].lower()
                save_color_scheme(self.color_scheme)
                self.setup_colors()
                break
            elif key == 27:  # ESC key
                break

        del color_win

    def toggle_help_screen(self):
        if self.view_mode == "help":
            self.view_mode = "main"
        else:
            self.view_mode = "help"

    def background_update_check(self):
        while True:
            time.sleep(3600)  # Check every hour
            self.last_update_check = datetime.now()
            self.new_exploits_count = fetch_new_exploits()

def main(stdscr):
    app = ExploitApplication(stdscr)
    while app.handle_input():
        app.display()

if __name__ == "__main__":
    create_database()
    curses.wrapper(main)
